require 'spec_helper'
include Ruby2600::Constants

describe Ruby2600::TIA do

  subject(:tia) do
    tia = Ruby2600::TIA.new
    tia.cpu = mock('cpu', :step => 2)
    tia.riot = mock('riot', :pulse => nil)
    tia
  end

  def clear_tia_registers
    0.upto(0x7F) { |reg| tia[reg] = 0 }
  end

  describe '#initialize' do
    it 'should initialize with random values on registers' do
      registers1 = Ruby2600::TIA.new.instance_variable_get(:@reg)
      registers2 = tia.instance_variable_get(:@reg)

      registers1.should_not == registers2
    end

    it "should initialize with valid (byte-size) values on registers" do
      tia.instance_variable_get(:@reg).each do |register_value|
        (0..255).should cover register_value
      end
    end
  end

  describe '#scanline' do
    before { clear_tia_registers }

    context 'TIA-CPU integration' do
      it 'should spend 76 CPU cycles generating a scanline' do
        tia.cpu.stub(:step).and_return(2)
        tia.cpu.should_receive(:step).exactly(76 / 2).times

        tia.scanline
      end

      it 'should account for variable instruction lenghts' do
        # The 11 stubbed values below add up to 48 cycles. To make 76, TIA should
        # call it 7 more times (since it will return the last one, 4).
        tia.cpu.stub(:step).and_return(2, 3, 4, 5, 6, 7, 6, 5, 4, 2, 4)
        tia.cpu.should_receive(:step).exactly(11 + 7).times

        tia.scanline
      end

      it "should account for multiple lines with unmatching instruction size" do
        # 76 / 3 will be a "split" instruction (25 1/3), but they should add up
        # back to 76 in the course of three lines
        tia.cpu.stub(:step).and_return(3)
        tia.cpu.should_receive(:step).exactly(76).times

        tia.scanline
        tia.scanline
        tia.scanline
      end
    end

    context 'TIA-RIOT integtation' do
      it 'should pulse RIOT 76 times while generating a scanline, regardless of CPU timing' do
        tia.cpu.stub(:step) { rand(5) + 2 }
        tia.riot.should_receive(:pulse).exactly(76).times

        tia.scanline
      end
    end

    context 'PF0, PF1, PF2' do
      before do
        tia[COLUBK] = 0xBB
        tia[COLUPF] = 0xFF
      end

      context 'all-zeros playfield' do
        it 'should generate a fullscanline with background color' do
          tia.scanline.should == Array.new(160, 0xBB)
        end
      end

      context 'all-ones playfield' do
        before { tia[PF0] = tia[PF1] = tia[PF2] = 0xFF }

        it 'should generate a fullscanline with foreground color' do
          tia.scanline.should == Array.new(160, 0xFF)
        end
      end

      context 'pattern playfield' do
        before do
          tia[PF0] = 0b01000101
          tia[PF1] = 0b01001011
          tia[PF2] = 0b01001011
        end

        it 'should generate matching pattern' do
          tia.scanline.should == [0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB,
                                  0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB]
        end
      end
    end

    context 'CTRLPF' do
      before do
        tia[COLUBK] = 0xBB
        tia[COLUPF] = 0xFF
        tia[COLUP0] = 0x11
        tia[COLUP1] = 0x22

        tia[PF0] = 0b01000101
        tia[PF1] = 0b01001011
        tia[PF2] = 0b01001011
      end

      it 'should generate symmetrical playfield if bit 0 (reflect) is set' do
        tia[CTRLPF] = 0b00000001

        tia.scanline.should == [0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB,
                                0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB]
      end

      it 'should use player colors for playfield if bit 1 is set (score mode)' do
        tia[CTRLPF] = 0b00000010

        tia.scanline.should == [0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x11, 0x11, 0x11, 0x11, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x11, 0x11, 0x11, 0x11, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x11, 0x11, 0x11, 0x11, 0xBB, 0xBB, 0xBB, 0xBB, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xBB, 0xBB, 0xBB, 0xBB, 0x11, 0x11, 0x11, 0x11, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x11, 0x11, 0x11, 0x11, 0xBB, 0xBB, 0xBB, 0xBB,
                                0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x22, 0x22, 0x22, 0x22, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x22, 0x22, 0x22, 0x22, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x22, 0x22, 0x22, 0x22, 0xBB, 0xBB, 0xBB, 0xBB, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0xBB, 0xBB, 0xBB, 0xBB, 0x22, 0x22, 0x22, 0x22, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x22, 0x22, 0x22, 0x22, 0xBB, 0xBB, 0xBB, 0xBB]
      end

      it 'should combine score mode and reflect' do
        tia[CTRLPF] = 0b00000011

        tia.scanline.should == [0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x11, 0x11, 0x11, 0x11, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x11, 0x11, 0x11, 0x11, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x11, 0x11, 0x11, 0x11, 0xBB, 0xBB, 0xBB, 0xBB, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xBB, 0xBB, 0xBB, 0xBB, 0x11, 0x11, 0x11, 0x11, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x11, 0x11, 0x11, 0x11, 0xBB, 0xBB, 0xBB, 0xBB,
                                0xBB, 0xBB, 0xBB, 0xBB, 0x22, 0x22, 0x22, 0x22, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x22, 0x22, 0x22, 0x22, 0xBB, 0xBB, 0xBB, 0xBB, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0xBB, 0xBB, 0xBB, 0xBB, 0x22, 0x22, 0x22, 0x22, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x22, 0x22, 0x22, 0x22, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x22, 0x22, 0x22, 0x22, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB]
      end

      it 'should get its color ahead of players/missiles if bit 2 is set (priority'

      it 'should contorl ball size (bits 4 and 5)'
    end

    context 'WSYNC' do
      def write_to_wsync_on_6th_call
        @step_counter ||= 0
        @step_counter += 1
        tia[WSYNC] = rand(256) if @step_counter == 6
        2
      end

      it 'should stop calling the CPU if WSYNC is written to' do
        tia.cpu.stub(:step) { write_to_wsync_on_6th_call }
        tia.cpu.should_receive(:step).exactly(6).times

        tia.scanline
      end
    end

    context 'VBLANK' do
      before do
        tia[COLUBK] = 0xBB
        tia[COLUPF] = 0xFF
        tia[PF0]    = 0xF0
        tia[PF1]    = 0xFF
        tia[PF2]    = 0xFF
      end

      it 'should generate a black scanline when "blanking" bit is set' do
        tia[VBLANK] = rand_with_bit(1, :set)

        tia.scanline.should == Array.new(160, 0x00)
      end

      it 'should generate a normal scanline when "blanking" bit is clear' do
        tia[VBLANK] = rand_with_bit(1, :clear)

        tia.scanline.should == Array.new(160, 0xFF)
      end

      pending "Latches: INPT4-INPT5 bit (6) and INPT6-INPT7 bit(7)"
    end

    context 'RESBL/ENABL' do
      before { tia[COLUPF] = 0xC0 }

      def write_register_after_cycles(register, cpu_cycles)
        @delay_counter ||= 0
        @delay_counter += 1 unless @delay_counter = :disabled

        if @delay_counter != :disabled && @delay_counter > cpu_cycles
          tia[register] = rand(256)
          @delay_counter = :disabled
        end

        1
      end

      context 'ENABL bit 1 reset' do
        before { tia[ENABL]  = 0 }

        it 'should not draw the ball on any scanline' do
          2.times { tia.scanline.should == Array.new(160, 0x00) }
        end
      end

      context 'ENABL bit 1 set' do
        before { tia[ENABL]  = 0b00000010 }

        context 'set during horizontal blank' do
          it 'should position ball on the left of screen, plus two pixels' do
            tia[RESBL] = rand(256)

            tia.scanline[0..2].should == [0x00, 0x00, 0xC0]
          end
        end

        context 'set on an arbitrary position' do
          before do
            tia.scanline
            tia.cpu.stub(:step) { write_register_after_cycles RESBL, 0 }
          end

          it 'should position ball on the appropriate position of the following scanline' do
            expected = Array.new(160, 0x00)
            expected[60] = 0xC0

            tia.scanline
            tia.scanline.should == expected
          end

          it 'should not affect the current scanline' do
            tia.scanline.should == Array.new(160, 0x00)
          end
        end
      end
    end
  end

  # The "ideal" NTSC frame has 259 scanlines (+3 of vsync, which we don't return),
  # but we should allow some leeway (we won't emulate "screen roll" that TVs do
  # with irregular frames)

  describe '#frame' do
    def build_frame(lines)
      @counter ||= -10 # Start on the "previous" frame
      @counter += 1
      case @counter
      when 0, lines + 3 then tia[VSYNC] = rand_with_bit(1, :set)   # Begin frame
      when 3            then tia[VSYNC] = rand_with_bit(1, :clear) # End frame
      end
      tia[WSYNC] = 255 # Finish scanline
      2
    end

    258.upto(260).each do |lines|
      it "should generate a frame with #{lines} scanlines" do
      tia.cpu.stub(:step) { build_frame(lines) }

      tia[VSYNC] = rand_with_bit 1, :clear
      tia.frame
      tia.frame.size.should == lines
      end
    end
  end
end
